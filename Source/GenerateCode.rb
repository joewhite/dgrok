require 'yaml'

def fieldname(s)
  "_" + s.sub(/^[A-Z]/) {|m| m.downcase}
end
def varname(s)
  result = s.sub(/^[A-Z]/) {|m| m.downcase}
  csharp_keywords = %w|case class const default do else finally for goto
    if in interface object operator string try while|
  if csharp_keywords.include?(result)
    result = "the" + s
  end
  result
end

Property = Struct.new(:name, :type)

class GenFile
  def initialize
    @codegen_yaml = YAML.load_file("CodeGen.yaml")
    @node_types = @codegen_yaml['NodeTypes']
  end
  
  def each_node_type
    sorted_node_types.each do |type_name|
      fail "Node classes must end with 'Node'" if type_name !~ /Node$/
      properties = @node_types[type_name].map do |item|
        if item.class == Hash
          Property.new(item['Name'], item['Type'])
        else
          Property.new(item, "AstNode")
        end
      end
      sorted_properties = properties.sort_by {|i| i.name.downcase}
      yield type_name, properties, sorted_properties
    end
  end
  
  def lines
    cs = []
    cs << IO.read('osl-notice.txt')
    cs << "// Autogenerated file - do not edit"
    cs << ""
    cs += body
    cs
  end
  
  def save
    text = lines.join("\n") + "\n"
    if !File.exist?(filename) || text != IO.read(filename)
      File.open(filename, "w") do |file|
        file.write(text)
      end
    end
  end
  
  def sorted_node_types
    @node_types.keys.sort_by {|i| i.downcase}
  end
end

class GeneratedNodes < GenFile
  def body
    cs = []
    cs << "using System;"
    cs << "using System.Collections.Generic;"
    cs << "using System.Text;"
    cs << "using DGrok.Framework;"
    cs << ""
    cs << "namespace DGrok.DelphiNodes"
    cs << "{"

    each_node_type do |type_name, properties, sorted_properties|
      cs << "    public partial class #{type_name} : NonterminalNode"
      cs << "    {"
      sorted_properties.each do |prop|
        cs << "        private #{prop.type} #{fieldname(prop.name)};"
      end
      cs << ""
      params = properties.map {|item| "#{item.type} #{varname(item.name)}"}
      cs << "        public #{type_name}(#{params.join(', ')})"
      cs << "        {"
      properties.each do |prop|
        cs << "            #{fieldname(prop.name)} = #{varname(prop.name)};"
      end
      cs << "        }"
      cs << ""
      sorted_properties.each do |prop|
        cs << "        public #{prop.type} #{prop.name}"
        cs << "        {"
        cs << "            get { return #{fieldname(prop.name)}; }"
        cs << "        }"
      end
      cs << ""
      cs << "        public override " +
        "IEnumerable<KeyValuePair<string, AstNode>> Properties"
      cs << "        {"
      cs << "            get"
      cs << "            {"
      properties.each do |prop|
        cs << "                yield return new " +
          "KeyValuePair<string, AstNode>(\"#{prop.name}\", #{prop.name});"
      end
      cs << "            }"
      cs << "        }"
      cs << ""
      cs << "        public override void Accept(Visitor visitor)"
      cs << "        {"
      cs << "            visitor.Visit#{type_name}(this);"
      cs << "        }"
      cs << "    }"
    end

    cs << "}"
    cs
  end
  
  def filename
    "DGrok.Framework/DelphiNodes/GeneratedNodes.cs"
  end
end

class GeneratedVisitor < GenFile
  def body
    cs = []
    cs << "using System;"
    cs << "using System.Collections.Generic;"
    cs << "using System.Text;"
    cs << "using DGrok.DelphiNodes;"
    cs << ""
    cs << "namespace DGrok.Framework"
    cs << "{"
    cs << "    public partial class Visitor"
    cs << "    {"
    each_node_type do |type_name, properties, sorted_properties|
      cs << "        public virtual void Visit#{type_name}(#{type_name} node)"
      cs << "        {"
      properties.each do |prop|
        cs << "            Visit(node.#{prop.name});"
      end
      cs << "        }"
    end
    cs << "    }"
    cs << "}"
    cs
  end
  
  def filename
    "DGrok.Framework/Framework/GeneratedVisitor.cs"
  end
end

GeneratedNodes.new.save
GeneratedVisitor.new.save